{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hi! My name is Anatoly Scherbakov, and this is my little personal site. See: A few random articles that I've written, My ongoing projects , Unfinished ideas , and CV . Why yeti ? I've lived in mountains of Siberia for quite a while. Cold, snow, mountains, forest, \u2014 who else would you expect to meet there indeed?","title":"Home"},{"location":"#why-yeti","text":"I've lived in mountains of Siberia for quite a while. Cold, snow, mountains, forest, \u2014 who else would you expect to meet there indeed?","title":"Why yeti?"},{"location":"articles/","text":"{{ blog_content }}","title":"Articles"},{"location":"articles/bash-basename/","text":"bash-3.2$ FILENAME = somefile.tar.gz bash-3.2$ echo \" ${ FILENAME %%.* } \" somefile bash-3.2$ echo \" ${ FILENAME %.* } \" somefile.tar","title":"Extract base name & extension in bash"},{"location":"articles/terminal-recorder/","text":"Output Format Scripting Runs Commands Archived @ GitHub https://asciinema.org https://github.com/faressoft/terminalizer svg false https://github.com/ines/termynal true false https://github.com/marionebl/svg-term-cli https://github.com/mjording/ttyrec https://github.com/nbedos/termtosvg true https://github.com/neatsoftware/term-sheets gif true false https://github.com/ovh/ovh-ttyrec https://github.com/pawamoy/shelldemo https://github.com/sloria/doitlive https://github.com/slowli/term-transcript/cli true true","title":"Terminal recorder"},{"location":"articles/tmux/","text":"See in Whimsical .","title":"tmux"},{"location":"articles/walrus/","text":"Python walrus operator has been a source of controversy in the community. Let's list a few of its use cases. Conditions if ( status := subsystem . Something () . status ) . is_success (): return status pytest Provide an informative assertion error message in pytest . def test_something (): assert ( response := requests . get ( ... ) ) . json () == { 'foo' : 'bar' }, response . text Antipatterns \u2254 + \u03bb Linters? What do we have on linters' front about walrus? Parallels let in Rust Monads?","title":"Apology of the walrus operator"},{"location":"articles/walrus/#conditions","text":"if ( status := subsystem . Something () . status ) . is_success (): return status","title":"Conditions"},{"location":"articles/walrus/#pytest","text":"Provide an informative assertion error message in pytest . def test_something (): assert ( response := requests . get ( ... ) ) . json () == { 'foo' : 'bar' }, response . text","title":"pytest"},{"location":"articles/walrus/#antipatterns","text":"\u2254 + \u03bb Linters? What do we have on linters' front about walrus?","title":"Antipatterns"},{"location":"articles/walrus/#parallels","text":"let in Rust Monads?","title":"Parallels"},{"location":"articles/cs111/","text":"","title":"CS111 Discrete Mathematics"},{"location":"articles/cs111/bounds-extremum-infimum/","text":"See in Whimsical .","title":"Bounds, extremum, & infimum"},{"location":"articles/cs111/cantor-theorem/","text":"See in Whimsical .","title":"Cantor's theorem"},{"location":"articles/cs111/functions/","text":"See in Whimsical .","title":"Functions"},{"location":"articles/cs111/max-and-min/","text":"See in Whimsical .","title":"Max & Min"},{"location":"articles/cs111/relations/","text":"See in Whimsical .","title":"Relations"},{"location":"articles/cs111/algebraic-structures/","text":"See in Whimsical .","title":"Algebraic Structures"},{"location":"articles/cs111/algebraic-structures/abelian-group/","text":"See in Whimsical .","title":"Abelian Group"},{"location":"articles/cs111/algebraic-structures/field/","text":"See in Whimsical .","title":"Field"},{"location":"articles/cs111/algebraic-structures/group/","text":"See in Whimsical .","title":"Group"},{"location":"articles/cs111/algebraic-structures/monoid/","text":"See in Whimsical .","title":"Monoid"},{"location":"articles/cs111/algebraic-structures/ring/","text":"See in Whimsical .","title":"Ring"},{"location":"articles/mkdocs-blog-plugins/","text":"MkDocs was designed to manage software project documentation, but in fact it is a very wide purpose static site generator. Can you use it to write your personal blog? Yes, most assuredly. Here are a few plugins for that. Last Commit Latest Release Github Stars Requires Nested Dirs Supports Frontmatter \ud83c\udff7\ufe0f Tags \ud83d\udcac Notes \u2714\ufe0f My Choice https://github.com/andyoakley/mkdocs-blog docs://articles/mkdocs-blog-plugins/index.md/b0 docs://articles/mkdocs-blog-plugins/index.md/b1 Looks unmaintained \u2639 https://github.com/derJD/python-mkblog docs://articles/mkdocs-blog-plugins/index.md/b2 docs://articles/mkdocs-blog-plugins/index.md/b3 https://github.com/fmaida/mkdocs-blog-plugin docs://articles/mkdocs-blog-plugins/index.md/b4 false https://github.com/liang2kl/mkdocs-blogging-plugin docs://articles/mkdocs-blog-plugins/index.md/b6 docs://articles/mkdocs-blog-plugins/index.md/b7 true Uses front matter or Git log to retrieve date per blog entry. docs://articles/mkdocs-blog-plugins/index.md/b5 https://github.com/vuquangtrong/mkdocs-material-blog true Is a theme, not a plugin.","title":"MkDocs plugins for blogging"},{"location":"cv/","text":"Key Expertise Design and architecture of business automation software Its implementation in Python programming language Code review, peer programming Keeping code clean & maintainable Currently Software Developer at Datafold | datafold.com Creating solutions to make data engineers' life better. Technologies Code Python 3 | mypy, flake8 | Pydantic, FastAPI | pandas | A bit of Rust Storage & Communication Systems PostgreSQL | Redis | MongoDB | ElasticSearch IaC & AWS Lambda, S3, EC2, ECS, RDS, SQS, Glue, Step Functions, EventBridge, Redshift | Terraform | CircleCI Misc Git | JIRA | PyCharm IDE Career 2012 \u2014 2022 | Recall Masters Inc \u2014 Senior Software Developer, Team Lead Recall Masters Inc (California, US) \u2014 An Automotive Safety Company \u2014 recallmasters.com Implemented the first MVP and, subsequently, the full fledged automation app on Django to support the company's business process. Built the internal development department supporting the system and moving forward together with the growing business. Handling the transfer from the monolith application to microservices based system. 2011 \u2014 2014 | Vboost Inc \u2014 Software Developer Vboost Inc (California, US) \u2014 An Automotive Marketing Company \u2014 vboost.com Built an MVP and then the full scaled business automation system on Python/Django. Invited developers and formed a small dev team to support the project. 2012 | Freelance odesk.com (now upwork.com ) A number of projects, mostly in Python and Django. The latter, at some point, became one of my favorite tools. 2008 \u2014 2011 | OngNet Inc \u2014 Web Developer OngNet Inc (Gorno-Altaysk, Russia) \u2014 Region scale broadband internet provider Company website (in PHP and subsequently Python). Internal automation for billing system and routing. 2007 \u2014 2013 | Tomsk University of Control Systems and Microelectronics \u2014 student TUCSR (Tomsk, Russia) \u2014 One of the leading tech universities of Russia to the east of Urals Major: Applied Computer Science in Economics Degree: specialist/engineer, with honors Thesis: Discrete Event Simulation of Business Processes Kind of childish one, actually Online education","title":"CV"},{"location":"cv/#key-expertise","text":"Design and architecture of business automation software Its implementation in Python programming language Code review, peer programming Keeping code clean & maintainable","title":"Key Expertise"},{"location":"cv/#currently","text":"Software Developer at Datafold | datafold.com Creating solutions to make data engineers' life better.","title":"Currently"},{"location":"cv/#technologies","text":"","title":"Technologies"},{"location":"cv/#code","text":"Python 3 | mypy, flake8 | Pydantic, FastAPI | pandas | A bit of Rust","title":"Code"},{"location":"cv/#storage-communication-systems","text":"PostgreSQL | Redis | MongoDB | ElasticSearch","title":"Storage &amp; Communication Systems"},{"location":"cv/#iac-aws","text":"Lambda, S3, EC2, ECS, RDS, SQS, Glue, Step Functions, EventBridge, Redshift | Terraform | CircleCI","title":"IaC &amp; AWS"},{"location":"cv/#misc","text":"Git | JIRA | PyCharm IDE","title":"Misc"},{"location":"cv/#career","text":"","title":"Career"},{"location":"cv/#2012-2022-recall-masters-inc-senior-software-developer-team-lead","text":"Recall Masters Inc (California, US) \u2014 An Automotive Safety Company \u2014 recallmasters.com Implemented the first MVP and, subsequently, the full fledged automation app on Django to support the company's business process. Built the internal development department supporting the system and moving forward together with the growing business. Handling the transfer from the monolith application to microservices based system.","title":"2012 \u2014 2022 | Recall Masters Inc \u2014 Senior Software Developer, Team Lead"},{"location":"cv/#2011-2014-vboost-inc-software-developer","text":"Vboost Inc (California, US) \u2014 An Automotive Marketing Company \u2014 vboost.com Built an MVP and then the full scaled business automation system on Python/Django. Invited developers and formed a small dev team to support the project.","title":"2011 \u2014 2014 | Vboost Inc \u2014 Software Developer"},{"location":"cv/#2012-freelance","text":"odesk.com (now upwork.com ) A number of projects, mostly in Python and Django. The latter, at some point, became one of my favorite tools.","title":"2012 | Freelance"},{"location":"cv/#2008-2011-ongnet-inc-web-developer","text":"OngNet Inc (Gorno-Altaysk, Russia) \u2014 Region scale broadband internet provider Company website (in PHP and subsequently Python). Internal automation for billing system and routing.","title":"2008 \u2014 2011 | OngNet Inc \u2014 Web Developer"},{"location":"cv/#2007-2013-tomsk-university-of-control-systems-and-microelectronics-student","text":"TUCSR (Tomsk, Russia) \u2014 One of the leading tech universities of Russia to the east of Urals Major: Applied Computer Science in Economics Degree: specialist/engineer, with honors Thesis: Discrete Event Simulation of Business Processes Kind of childish one, actually Online education","title":"2007 \u2014 2013 | Tomsk University of Control Systems and Microelectronics \u2014 student"},{"location":"ideas/","text":"In this section of the site, I publish ideas for projects I haven't got time or energy to even start. These pages are intended to: structure my thoughts on these subjects, get these thoughts out of my system, free my mind to think about the issues at hand rather than distracting to something new that tries to grasp my imagination, and perhaps provide groundwork to start those projects someday in the future \u2014 maybe to myself or to someone else. Consider this section of the site a shameless collection of quick and dirty drafts.","title":"\ud83d\udca1 Ideas"},{"location":"ideas/interplanner/","text":"Target audience Linked Data community, Tech-savvy individuals, Companies, Individuals from the general audience, Government agencies, the humanity as a whole. Problem When you have a plan, normally the reality never goes exactly as planned. Every kind of random things happen, disrupting the plans of individuals, companies, governments, and the whole of mankind. Planning is extremely difficult to get right. However, it is still very much necessary for survival on all levels: from an individual to the whole species. We have huge problems which can't be solved without such a level of planning: improve education on a global scale, solve the shortage of energy, prevent pandemics proactively, solve the global climate change, from producing waste, go to a closed-cycle economically viable manufacturing system, evolve to become an interplanetary species, \u2026 These issues will define it whether we survive \u2014 or we die out. In order to make planning useful, our plans need to satisfy the following criteria. the planning system of an individual, organization, or the whole human race must include multiple different scenarios of what might happen; there must be scenarios on multiple levels: short-term, mid-term, long-term; every scenario must be assigned a probability, at least relative and crude, of its coming into existence; the scenarios, especially short term ones, must be revised constantly. We do not have a system that does that, at least, semi-automatically. Essence interplanner is a headless planning maintenance system that operates over an iolanta -capable semantic graph. That permits to use iolanta oracles to retrieve data from sources, and to upload the results of planning to the graph whatever medium it might use. Inputs of interplanner are semantic data from any kind of source: time tracking records, existing short-term plans manually managed by the person in a tool like Todoist, oracles of neural network systems, financial statements, cost and income estimates, projected events and their frames (min time \u2026 max time), wikidata, dbpedia, github, any other information source supported by iolanta ecosystem. interplanner outputs an RDF dataset which encodes (typically very many) scenarios: every scenario is a sequence of events, each tied to time, events might be accompanied by financial information, links to external resources, whatever else, each scenario might be ranked. Info Perhaps rename this tool to scenarist or scriptwriter ? How is this done? Judging from the input data, interplanner will do the following stages. Combinatorial explosion. Given the input data and the time frame to plan for, it will first deduce every scenario that is possible given the input data. This stage will give us a huge number of scenarios. Selection. Exclude the scenarios which are impossible. exclude events which are of too low probability over the time span we are planning for, if a scenario contains mutually exclusive events then skip it, if this scenario is conflicting with a plan of another level, skip it, etc. Optimization. Rank every scenario according to the optimization function the user has requested. That might be time spent on certain tasks, or achievement of certain goals, or whatever. As a result of an interplanner run we get a semantic graph of scenarios from which we can choose those that we like. Multiple such incarnations can be used in a hierarchical manner. You can't recalculate the global plan for the whole of humanity every day, it's too large; but you can recalculate small pieces of it here and there, and use their integrated results as inputs for the master strategy. Vocabulary examples interplanner will very heavily rely upon other systems. For example, - accounting/financial systems to understand what we can afford, - legal data to know how much time a person can work and which days are holidays or days off. In general, something like this can be imagined: requiresTime to define how long an event or task takes to be completed, hasPreRequisite to define relationships between tasks, hasProbabililty defines how possible an event is, \u2026 State of the art Design methods by G. K. Jones Existing Optimization systems, if any Discrete optimization methods and strategies Evolution Octadocs? Can this be an application of Octadocs? How can it be used to improve software project documentation in view of how companies plan their work with task trackers? I do not know at this point. iolanta first this will probably be a personal tool, and then it can be expanded to be able to upload scenarios to IPFS and render them from there. \u2026","title":"interplanner"},{"location":"ideas/interplanner/#target-audience","text":"Linked Data community, Tech-savvy individuals, Companies, Individuals from the general audience, Government agencies, the humanity as a whole.","title":"Target audience"},{"location":"ideas/interplanner/#problem","text":"When you have a plan, normally the reality never goes exactly as planned. Every kind of random things happen, disrupting the plans of individuals, companies, governments, and the whole of mankind. Planning is extremely difficult to get right. However, it is still very much necessary for survival on all levels: from an individual to the whole species. We have huge problems which can't be solved without such a level of planning: improve education on a global scale, solve the shortage of energy, prevent pandemics proactively, solve the global climate change, from producing waste, go to a closed-cycle economically viable manufacturing system, evolve to become an interplanetary species, \u2026 These issues will define it whether we survive \u2014 or we die out. In order to make planning useful, our plans need to satisfy the following criteria. the planning system of an individual, organization, or the whole human race must include multiple different scenarios of what might happen; there must be scenarios on multiple levels: short-term, mid-term, long-term; every scenario must be assigned a probability, at least relative and crude, of its coming into existence; the scenarios, especially short term ones, must be revised constantly. We do not have a system that does that, at least, semi-automatically.","title":"Problem"},{"location":"ideas/interplanner/#essence","text":"interplanner is a headless planning maintenance system that operates over an iolanta -capable semantic graph. That permits to use iolanta oracles to retrieve data from sources, and to upload the results of planning to the graph whatever medium it might use. Inputs of interplanner are semantic data from any kind of source: time tracking records, existing short-term plans manually managed by the person in a tool like Todoist, oracles of neural network systems, financial statements, cost and income estimates, projected events and their frames (min time \u2026 max time), wikidata, dbpedia, github, any other information source supported by iolanta ecosystem. interplanner outputs an RDF dataset which encodes (typically very many) scenarios: every scenario is a sequence of events, each tied to time, events might be accompanied by financial information, links to external resources, whatever else, each scenario might be ranked. Info Perhaps rename this tool to scenarist or scriptwriter ?","title":"Essence"},{"location":"ideas/interplanner/#how-is-this-done","text":"Judging from the input data, interplanner will do the following stages. Combinatorial explosion. Given the input data and the time frame to plan for, it will first deduce every scenario that is possible given the input data. This stage will give us a huge number of scenarios. Selection. Exclude the scenarios which are impossible. exclude events which are of too low probability over the time span we are planning for, if a scenario contains mutually exclusive events then skip it, if this scenario is conflicting with a plan of another level, skip it, etc. Optimization. Rank every scenario according to the optimization function the user has requested. That might be time spent on certain tasks, or achievement of certain goals, or whatever. As a result of an interplanner run we get a semantic graph of scenarios from which we can choose those that we like. Multiple such incarnations can be used in a hierarchical manner. You can't recalculate the global plan for the whole of humanity every day, it's too large; but you can recalculate small pieces of it here and there, and use their integrated results as inputs for the master strategy.","title":"How is this done?"},{"location":"ideas/interplanner/#vocabulary-examples","text":"interplanner will very heavily rely upon other systems. For example, - accounting/financial systems to understand what we can afford, - legal data to know how much time a person can work and which days are holidays or days off. In general, something like this can be imagined: requiresTime to define how long an event or task takes to be completed, hasPreRequisite to define relationships between tasks, hasProbabililty defines how possible an event is, \u2026","title":"Vocabulary examples"},{"location":"ideas/interplanner/#state-of-the-art","text":"Design methods by G. K. Jones Existing Optimization systems, if any Discrete optimization methods and strategies","title":"State of the art"},{"location":"ideas/interplanner/#evolution","text":"Octadocs? Can this be an application of Octadocs? How can it be used to improve software project documentation in view of how companies plan their work with task trackers? I do not know at this point. iolanta first this will probably be a personal tool, and then it can be expanded to be able to upload scenarios to IPFS and render them from there. \u2026","title":"Evolution"},{"location":"ideas/terry/","text":"Problem While coding, a developer sometimes notices an issue, something that has to be addessed in the future but isn't strictly related to the developer's current task at hand. The developer might: ignore the issue; decide to get to it later, immediately forget, and never return; write it down somewhere on a scratch of paper which will subsequently be found by the developer's cat and made away with; write a TODO comment which will never be tracked and remembered of; make a ticket in the project's task management system. The last is the best thing to do in the long term, but it forces the developer to switch context, and breaks concentration. Approach There has been an idea to combine the last two alternatives and write a specially formed TODO or FIXME comments. For instance: # fixme: # title: Rename do_something function to reflect what it is really doing # assignee: me # priority: low def do_something (): ... An automatic system will then parse this comment and create an issue in the project's task management system itself. Such a comment is known as a puzzle . The idea is named Puzzle Driven Development (PDD) and is apparently proposed by Egor Bugaenko. Previous art See state-of-the-art.yaml . Todo Visualize that. Todo I believe Bugaenko's zerocrat is a complex solution that does multiple things. I'd want to create a very simple tool for the same exact purpose and a more modular one, supporting different task management systems. The tool might be named terry after Terry Gilliam, who played Bridge Keeper in Monty Python and the Holy Grail, an antagonist who asked people hard questions. Or puzzles. Just as what we're doing here. So the workflow is like this: you write a FIXME or TODO comment just as described above; that comment is formatted as YAML. When you run terry CLI tool against your code base (as a pre-commit hook, for example), it will search for such comments and resolve them. Meaning, the comment will be changed and will now look like this: # fixme: # id: https://github.com/vasya/pupkin/issues/15 # title: Rename do_something function to reflect what it is really doing # assignee: me # priority: low def do_something (): ... A GitHub issue has been created from this comment. Now the comment is considered resolved . You can proceed with committing this to the repo. How this helps In the spirit of PDD, this allows to keep tasks/issues small and therefore more manageable. This prevents changes of focus, works with multiple programming and markup languages, is open source, very small, and works very fast even on humongous code bases due to massive parallelism. Implementation Perhaps such a thing already exist? [] Research Language: Python (+) There are great YAML libraries (+) Faster to develop (+) Easier to create a plugin system (-) Harder to do parallelism (-) Harder to make it fast Rust (+) Much better parallelism and faster to run (+) More personally educational for the author (-) Slower to develop (?) Is there a library like Python YAML libraries which preserve exact formatting of the document while editing it? (?) Plugin system based on what? JSON-RPC! Can one do this at all BTW? Patent is abandoned , so yes. How do we build integrations with task management systems? Plainly as plugins with standardized API Or somehow via a semantic interaction layer, if that makes sense How does it make sense? I have no idea ATM How do we integrate with different programming & markup languages? Extract the relevant piece of code, Make account of the function, class, module where the comment is located, Format all this beautifully and insert into the newly created ticket Do we care about changes? For example, when we update the puzzle comment, do we then go and update the ticket? How do we make sure we don't overwrite whatever humans have already written there? Extensions Datadog specify measurement units for metrics create alerts Calendars Schedule meetings? Octadocs Ingest information into the graph (hey this might prove interesting as an integration method actually) This might shift the whole focus of the tool This might mean we will use pytkdocs to parse stuff but then how to write back??","title":"Terry"},{"location":"ideas/terry/#problem","text":"While coding, a developer sometimes notices an issue, something that has to be addessed in the future but isn't strictly related to the developer's current task at hand. The developer might: ignore the issue; decide to get to it later, immediately forget, and never return; write it down somewhere on a scratch of paper which will subsequently be found by the developer's cat and made away with; write a TODO comment which will never be tracked and remembered of; make a ticket in the project's task management system. The last is the best thing to do in the long term, but it forces the developer to switch context, and breaks concentration.","title":"Problem"},{"location":"ideas/terry/#approach","text":"There has been an idea to combine the last two alternatives and write a specially formed TODO or FIXME comments. For instance: # fixme: # title: Rename do_something function to reflect what it is really doing # assignee: me # priority: low def do_something (): ... An automatic system will then parse this comment and create an issue in the project's task management system itself. Such a comment is known as a puzzle . The idea is named Puzzle Driven Development (PDD) and is apparently proposed by Egor Bugaenko.","title":"Approach"},{"location":"ideas/terry/#previous-art","text":"See state-of-the-art.yaml . Todo Visualize that.","title":"Previous art"},{"location":"ideas/terry/#todo","text":"I believe Bugaenko's zerocrat is a complex solution that does multiple things. I'd want to create a very simple tool for the same exact purpose and a more modular one, supporting different task management systems. The tool might be named terry after Terry Gilliam, who played Bridge Keeper in Monty Python and the Holy Grail, an antagonist who asked people hard questions. Or puzzles. Just as what we're doing here. So the workflow is like this: you write a FIXME or TODO comment just as described above; that comment is formatted as YAML. When you run terry CLI tool against your code base (as a pre-commit hook, for example), it will search for such comments and resolve them. Meaning, the comment will be changed and will now look like this: # fixme: # id: https://github.com/vasya/pupkin/issues/15 # title: Rename do_something function to reflect what it is really doing # assignee: me # priority: low def do_something (): ... A GitHub issue has been created from this comment. Now the comment is considered resolved . You can proceed with committing this to the repo.","title":"Todo"},{"location":"ideas/terry/#how-this-helps","text":"In the spirit of PDD, this allows to keep tasks/issues small and therefore more manageable. This prevents changes of focus, works with multiple programming and markup languages, is open source, very small, and works very fast even on humongous code bases due to massive parallelism.","title":"How this helps"},{"location":"ideas/terry/#implementation","text":"Perhaps such a thing already exist? [] Research Language: Python (+) There are great YAML libraries (+) Faster to develop (+) Easier to create a plugin system (-) Harder to do parallelism (-) Harder to make it fast Rust (+) Much better parallelism and faster to run (+) More personally educational for the author (-) Slower to develop (?) Is there a library like Python YAML libraries which preserve exact formatting of the document while editing it? (?) Plugin system based on what? JSON-RPC! Can one do this at all BTW? Patent is abandoned , so yes. How do we build integrations with task management systems? Plainly as plugins with standardized API Or somehow via a semantic interaction layer, if that makes sense How does it make sense? I have no idea ATM How do we integrate with different programming & markup languages? Extract the relevant piece of code, Make account of the function, class, module where the comment is located, Format all this beautifully and insert into the newly created ticket Do we care about changes? For example, when we update the puzzle comment, do we then go and update the ticket? How do we make sure we don't overwrite whatever humans have already written there?","title":"Implementation"},{"location":"ideas/terry/#extensions","text":"Datadog specify measurement units for metrics create alerts Calendars Schedule meetings? Octadocs Ingest information into the graph (hey this might prove interesting as an integration method actually) This might shift the whole focus of the tool This might mean we will use pytkdocs to parse stuff but then how to write back??","title":"Extensions"},{"location":"ideas/terry/decisions/001-plugin-communication/","text":"The main terry executable will communicate with language-specific and scheduler-specific plugins sending text-based messages to their stdin and reading analogous messages from their stdout. Context At the moment of writing this document, it isn't yet clear in what programming language to write terry . Anyway, I believe it to be important to ensure that plugins for terry must be language agnostic. Decision criteria : language-agnostic : title : Language Agnostic ease-of-debug : title : Debuggability alternatives : - title : socket-based communication language-agnostic : yes ease-of-debug : 3 - title : stdin/stdout communication language-agnostic : yes ease-of-debug : 1","title":"Communicate with plugins via stdin & stdout"},{"location":"ideas/terry/decisions/001-plugin-communication/#context","text":"At the moment of writing this document, it isn't yet clear in what programming language to write terry . Anyway, I believe it to be important to ensure that plugins for terry must be language agnostic.","title":"Context"},{"location":"ideas/terry/decisions/001-plugin-communication/#decision","text":"criteria : language-agnostic : title : Language Agnostic ease-of-debug : title : Debuggability alternatives : - title : socket-based communication language-agnostic : yes ease-of-debug : 3 - title : stdin/stdout communication language-agnostic : yes ease-of-debug : 1","title":"Decision"},{"location":"ideas/terry/decisions/002-communication-format/","text":"criteria : human-readable : title : Human Readable alternatives : - id : json-rpc human-readable : yes - id : protobuf human-readable : no","title":"Communication Format"},{"location":"ideas/terry/decisions/003-json-rpc-ld/","text":"@context declarations allow to modify the message format within certain bounds without breaking compatibility. Communicating components In certain circumstances, terry issues a command terry.dev/create-task which is expected to create a task with a title, description, type(s), and assignee. The task management plugin must create that task. terry-github plugin is built specifically for terry and understands that command. Everything is fine. Now what if we want to tie terry and a generic interfacing program for a task manager system? For instance, jira-jsonrpc-ld is a tool that accepts a different command: ld.dev/create-task , with different parameters. Can we make these two tools friends? Let's assume that we do not wish to change the source code of these tools. They need to be built from the beginning in a way which allows us to make them composable. Who is going to extend the hand? The two tools must use a format that both of them can understand. We have choices. alternatives : - id : ` terry` adapts its output title : ` terry` changes its JSON-RPC message format so that `jira-jsonrpc-ld` can understand it. good : no because : This will mean that `terry` must receive a communication from `jira-jsonrpc-ld` to explain at least something about the format the latter can understand. This means the one-way communication that we've been looking at converts into a two-way communication, dramatically increasing the complexity of the system. Let's avoid that. - id : ` jira-jsonrpc-ld` interprets `terry`'s output good : yes - id : ` terry-to-jira` intermediate program is written and placed between the counterparts. good : so-so because : This is probably unavoidable in many situations but let's try to get along without such an effort whenever possible. How will jira-jsonrpc-ld adapt the incoming message? The names of fields, their types and stuff \u2014 all of that is different for the two tools. I know two ways of coercing one into another without writing custom code in a general purpose language: alternatives : - id : json-ld-framing - id : rdf-and-owl !!! warning \"todo I have no evidence at this point to prefer one to the other. However, I do not know whether it is possible to coerce a document based on one ontology to another ontology with framing. With OWL, that's certainly possible but that requires more computing power. Further research is necessary.","title":"JSON-RPC messages are annotated with LD contexts"},{"location":"ideas/terry/decisions/003-json-rpc-ld/#communicating-components","text":"In certain circumstances, terry issues a command terry.dev/create-task which is expected to create a task with a title, description, type(s), and assignee. The task management plugin must create that task. terry-github plugin is built specifically for terry and understands that command. Everything is fine. Now what if we want to tie terry and a generic interfacing program for a task manager system? For instance, jira-jsonrpc-ld is a tool that accepts a different command: ld.dev/create-task , with different parameters. Can we make these two tools friends? Let's assume that we do not wish to change the source code of these tools. They need to be built from the beginning in a way which allows us to make them composable.","title":"Communicating components"},{"location":"ideas/terry/decisions/003-json-rpc-ld/#who-is-going-to-extend-the-hand","text":"The two tools must use a format that both of them can understand. We have choices. alternatives : - id : ` terry` adapts its output title : ` terry` changes its JSON-RPC message format so that `jira-jsonrpc-ld` can understand it. good : no because : This will mean that `terry` must receive a communication from `jira-jsonrpc-ld` to explain at least something about the format the latter can understand. This means the one-way communication that we've been looking at converts into a two-way communication, dramatically increasing the complexity of the system. Let's avoid that. - id : ` jira-jsonrpc-ld` interprets `terry`'s output good : yes - id : ` terry-to-jira` intermediate program is written and placed between the counterparts. good : so-so because : This is probably unavoidable in many situations but let's try to get along without such an effort whenever possible.","title":"Who is going to extend the hand?"},{"location":"ideas/terry/decisions/003-json-rpc-ld/#how-will-jira-jsonrpc-ld-adapt-the-incoming-message","text":"The names of fields, their types and stuff \u2014 all of that is different for the two tools. I know two ways of coercing one into another without writing custom code in a general purpose language: alternatives : - id : json-ld-framing - id : rdf-and-owl !!! warning \"todo I have no evidence at this point to prefer one to the other. However, I do not know whether it is possible to coerce a document based on one ontology to another ontology with framing. With OWL, that's certainly possible but that requires more computing power. Further research is necessary.","title":"How will jira-jsonrpc-ld adapt the incoming message?"},{"location":"projects/","text":"anatoly-scherbakov/documented : docstrings + placeholders = user friendly exception messages with next to no boilerplate. https://github.com/octadocs is a plugin for mkdocs.org that empowers a static site built on MkDocs with a queryable graph database. \u2014 Example: https://flake8.codes https://platonic.tools is a set of Python libraries to represent various backends as Pythonic data constructs (for example, a Redis collection as a Python dict ) https://github.com/anatoly-scherbakov/geopatterns-demo/ is a demo project to showcase how to write cloud-native Python code on AWS Lambda platform and manage it using HashiCorp Terraform, \u2014 prepared for, and demonstrated at, Barnaul Python Conf 2021 (see below) https://github.com/ysv-rs/ysv is a Rust command-line application that converts CSV input into CSV output, cleans and standardizes the data https://github.com/anatoly-scherbakov/vendetta is a Python app that generates CSV tables with randomized data based on YAML specifications for testing purposes","title":"Projects"}]}